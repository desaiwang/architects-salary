<html>

<head>
  <title>Architect's Salary</title>
  <link rel="icon" type="image/svg+xml" href="/desai_icon.svg" />
  <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Raleway:400,700" rel="stylesheet">
  <link href="./general-style.css" rel="stylesheet" type="text/css">
  <link href="./style.css" rel="stylesheet" type="text/css">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v2.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-tile@1"></script>

</head>

<body style="background-color: rgb(255, 255, 255);">
  <div style="margin-top:30px">
    <div id="header" style="margin-left:-100px">
      <h2 style="text-align: center"> Visualizing Architect's Salary in the US</h2>
      <h5 style="text-align: center; margin-top: -65px; margin-bottom: 50px"> Desai Wang</h5>
    </div>

    <div></div>

    <div id="container" style="display: flex; justify-content: center;">
      <svg id="vizIndividualsContainer" width="1200" height="1500"></svg>
      <div id="tooltip" class="tooltip" style="
        visibility:hidden;
        position:absolute; 
        background:white; 
        padding:10px; 
        border:1px solid black; 
        pointer-events:none;">
      </div>
      <div id="controlfilterSalary"></div>
      <div id="controlfilterSatisfaction"></div>
    </div>

  </div>



  </div>

  <div style="margin-bottom:100"></div>
  </div>





  <script>

    const vizIndividualsContainer = d3.select("svg#vizIndividualsContainer");
    const width = vizIndividualsContainer.attr("width");
    const height = vizIndividualsContainer.attr("height");

    const margins = {
      top: 20,
      bottom: 20,
      left: 20,
      right: 20
    }

    const vizHeight = height - margins.top - margins.bottom;
    const vizWidth = width - margins.left - margins.right;

    const vizIndividuals = vizIndividualsContainer.append("g")
      .attr("transform", `translate(${margins.left}, ${margins.top})`)

    const loadIndividuals = async function () {
      let dataAll = await d3.csv("data/241017_archinect_salaries_fulltime.csv", d3.autoType);
      console.log(dataAll);

      const satisfactionExtent = d3.extent(dataAll, d => d['Job Satisfaction'])
      //starting color in UI colors: #043565 for blue, #ff8f06 for orange using https://uicolors.app/create
      const satisfactionScale = d3.scaleQuantize(satisfactionExtent, ["#3c5491", "#4465b1", "#4e78c2", "#6290cf", "#a9c9e7", "#ffe3a8", "#ffce70", "#ff8f06", "#f07706", "#c75a07"])
      //const satisfactionScale = d3.scaleSequential(d3.interpolateRdYlGn).domain(satisfactionExtent)

      const salaryExtent = d3.extent(dataAll, d => d['Salary'])
      console.log(salaryExtent)

      const maxD = 10
      const salaryScale = d3.scaleLinear().domain(salaryExtent).range([2.5, 20])


      //create tooltip
      const tooltipDiv = d3.select("div#tooltip")

      //filter: this is used to for updates

      var filters = {};

      function pointPassesFilters(point) {

        let stillPassed = true;

        Object.values(filters).forEach(filterFunc => {

          stillPassed = filterFunc(point) && stillPassed;

        });

        return stillPassed;

      }

      function updateData() {
        let data = dataAll.filter(pointPassesFilters);

        const medianSalary = d3.median(data, d => d['Salary']);
        console.log("Median Salary:", medianSalary);
        const maxD = Math.ceil(salaryScale(medianSalary) * 2 + 2);
        console.log("calculated maxD", maxD)
        vizIndividuals.selectAll("circle")
          .data(data)
          .join("circle")
          .attr("cx", (d, i) => {
            // console.log("cx", i % (vizWidth / maxD) * maxD)
            return (Math.floor(i % (vizWidth / maxD)) * maxD)
          })
          .attr("cy", (d, i) => {
            // console.log("cy", Math.floor(i / vizWidth * maxD) * maxD)
            return (Math.floor(i / vizWidth * maxD) * maxD)
          })
          .attr("r", d => salaryScale(d['Salary']))
          .attr("opacity", 0.8)
          .attr("fill", d => {
            // console.log("job satisfaction", d['Job Satisfaction'])
            // console.log("satisfaction scale", satisfactionScale(d['Job Satisfaction']))
            return satisfactionScale(d['Job Satisfaction'])
          })
          .on("mouseover", function (event, d) {
            let selectedElement = d3.select(this)

            selectedElement.raise()
              .transition().duration(200)
              .attr("stroke", "black")
              .attr("stroke-width", 1)
              .attr("r", d => salaryScale(d['Salary']) + 5);

            tooltipDiv.html(`
            <strong>Salary:</strong> ${d3.format("$,")(d['Salary'])}<br>
            <strong>Job Satisfaction:</strong> ${d['Job Satisfaction']}/10<br>
            <strong>Age:</strong> ${d['Age']}<br>
            <strong>Years of Experience:</strong> ${d['Years of Experience']}<br>
            <strong>Location:</strong> ${d['Location']}<br>
            <strong>Survey Date:</strong> ${new Date(d['Date']).toLocaleString('default', { month: 'long', year: 'numeric' })}<br>
          `)
              .style("left", (event.pageX + 10) + "px")
              .style("top", (event.pageY + 10) + "px")
              .style("visibility", "visible");
          })
          .on("mouseout", function (event, d) {
            d3.select(this)
              .lower()
              .transition().duration(200)
              .attr("stroke", "none")
              .attr("r", d => salaryScale(d['Salary']));

            tooltipDiv.style("visibility", "hidden")
          })
      }

      function makeSlider(dataAll, container, label, attribute, sliderWidth, sliderHeight, maxLimit, scaleFormatter = d3.format(",.0f"), getButtonData = null) {

        // Get a raw array of values for this property
        let values = dataAll.map(d => d[attribute]).sort(function (a, b) { return b - a }); //sorted for optimization

        // Find min and max for some scales
        let minMax = [0, maxLimit];

        let xScale = d3.scaleLinear().domain(minMax)
          .range([10, sliderWidth - 20]); // padding here for ease

        let xAxis = d3.axisBottom(xScale)
          .tickFormat(function (d) {
            // console.log("interval", d);
            return (d == maxLimit) ? `> ${scaleFormatter(maxLimit)}` : scaleFormatter(d);
          })
          ;

        // Create some HTML elements
        let wrapper = container.append("div").attr("class", "controls").style("margin-top", "10px");
        wrapper.append("div").text(label);

        let rowwrapper = wrapper.append("div")
          .style("display", "flex")
          .style("flex-direction", "column")
          .style("align-items", "center");

        let canvas = rowwrapper.append("svg").attr("id", "capacity selection")
          .attr("width", sliderWidth)
          .attr("height", sliderHeight + 30)
          .attr("attribute", attribute);
        canvas.append("g").attr("transform", `translate(0,${sliderHeight})`)
          .call(xAxis);

        let buttons = rowwrapper.append("div")
          .style("display", "flex")
          .style("flex-direction", "row")
          .style("justify-content", "center");

        if (getButtonData) {
          let buttonData = getButtonData(attribute, values);
          buttons
            .selectAll("button")
            .data(buttonData)
            .enter()
            .append("button")
            .text(d => d.label)
            .style("margin-right", 8)
            .on("click", function (event, d) {
              brushRegion.call(brush.move, null)

              filters[attribute] = d.filterFunc;

              updateData();
            })
        }

        // Make an area chart
        let areaLayer = canvas.append("g");

        // generate histogram
        let numBins = 20;
        let histoGen = d3.histogram().domain(minMax)
          .thresholds(numBins);
        let counts = histoGen(values);

        // dummy object at start of graph
        counts.unshift({
          x0: 0,
          x1: counts[0].x0,
          length: counts[0].length
        });

        let yScale = d3.scaleLinear().domain(d3.extent(counts, d => d.length))
          .range([sliderHeight, 10]);

        // Area generator is like a lineGen, but we give y0 and y1 to fill it in
        let area = d3.area().x(d => xScale(d.x1))
          .y0(yScale(0))
          .y1(d => yScale(d.length))
          .curve(d3.curveNatural);

        // Adding the path works just like a line (the area generator just makes a filled region)
        areaLayer.append("path").datum(counts)
          .attr("class", "area")
          .attr("fill", "#9dbbed")
          .attr("d", area);


        let filterFunc = d => true;
        filters[attribute] = filterFunc;

        var brush = d3.brushX().extent([[10, 0], // Upper left corner
        [sliderWidth - 10, sliderHeight]])  // Lower right corner
          .on("brush end", brushMoved);

        function brushMoved(event) {
          // Everything but clicking on brush area
          if (event.selection !== null) {

            // Run scales in reverse to get data values for the ends of the brush
            //  If a scale turns data -> pixels, then scale.invert turns pixels -> data
            let start = xScale.invert(event.selection[0]);
            let end = xScale.invert(event.selection[1]);

            if (end > maxLimit - Math.floor(maxLimit * 0.001)) { end = Infinity; } //query all the power stations that are big.

            // Overwrite old filter in our dictionary
            // This filter now only returns True if the point's value is between start and end
            let filterFunc = d => d[attribute] >= start && d[attribute] <= end;
            filters[attribute] = filterFunc;

            updateData();

          }

          // Clicking on brush area to empty it out
          else {
            // Selected nothing, let everything pass
            let filterFunc = d => true;
            filters[attribute] = filterFunc;

            updateData();

          }

        }

        let brushRegion = canvas.append("g").attr("class", "brush")
        brushRegion.call(brush);
      }

      let controlSalary = d3.select("#controlfilterSalary");
      function getButtonDataSalary(attribute, values) {
        return [
          { label: "> $50k", filterFunc: d => d[attribute] > 50000 },
          { label: "> $100k", filterFunc: d => d[attribute] > 100000 },
          { label: "top 20 incomes", filterFunc: d => d[attribute] >= values[19] }
        ];
      }
      makeSlider(dataAll, controlSalary, "Salary", "Salary", 400, 100, 200000, d => d === 0 ? "$0" : d3.format("$.2s")(d), getButtonDataSalary);

      let controlSatisfaction = d3.select("#controlfilterSatisfaction");
      makeSlider(dataAll, controlSatisfaction, "Job Satisfaction", "Job Satisfaction", 400, 100, 12, d3.format(""));


      //call update data to draw the initial data
      updateData();

    }

    loadIndividuals();

  </script>
</body>

</html>
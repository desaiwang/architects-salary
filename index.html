<html>

<head>
  <title>Architect's Salary</title>
  <link rel="icon" type="image/svg+xml" href="/desai_icon.svg" />
  <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Raleway:400,700" rel="stylesheet">
  <link href="./general-style.css" rel="stylesheet" type="text/css">
  <link href="./style.css" rel="stylesheet" type="text/css">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v2.min.js"></script>
  <!-- <script src="https://cdn.jsdelivr.net/npm/d3-tile@1"></script> -->
  <script src="https://cdn.jsdelivr.net/npm/d3-hexbin@0.2"></script>

</head>

<body style="background-color: rgb(255, 255, 255);">
  <div style="margin-top:30px">
  </div>
  <div id="header">
    <!-- style="margin-left:-100px" -->
    <h2 style="text-align: center"> Visualizing Architect's Salary in the US</h2>
    <h5 style="text-align: center; margin-top: -65px; margin-bottom: 50px"> Desai Wang</h5>
  </div>

  <div style="display: flex; justify-content: center;">
    <h2 id="summaryText"></h2>
  </div>

  <div>
    <div id="hexbinMap">

    </div>
    <div id="container" style="display: flex; justify-content: center;">
      <div id="canvasContainer" style="position:relative; width:900px; height:1500px">
      </div>
      <div style="display: flex; flex-direction: column;">
        <div id="controlfilterTime"></div>
        <div id="controlfilterSalary"></div>
        <div id="controlfilterSatisfaction"></div>
        <div id="controlfilterFirmType"></div>
        <div id="controlfilterFirmSize"></div>
        <div id="controlfilterAge"></div>
        <div id="controlfilterAgeClass"></div>
      </div>
    </div>
  </div>
  </div>

  </div>
  <div style="margin-bottom:100"></div>
  </div>


  <script type="module">

    import { curveSlider } from './js/curveSlider.js';
    import { histogramSlider } from './js/histogramSlider.js';
    import { clickableHistogramSlider } from './js/clickableHistogramSlider.js';
    import { hexbinMap } from './js/hexbinMap.js';
    import { geoAlbersUsaPr } from "./js/geoAlbersUsaPr.js";
    import clickableHistogramSliderClass from './js/clickableHistogramSliderClass.js';

    //set up for individuals visualization
    const vizIndividualsContainer = d3.select("div#canvasContainer");
    const width = Number(vizIndividualsContainer.style("width").replace("px", ""));
    const height = Number(vizIndividualsContainer.style("height").replace("px", ""));

    const margins = {
      top: 20,
      bottom: 20,
      left: 20,
      right: 20
    }

    const vizHeight = height - margins.top - margins.bottom;
    const vizWidth = width - margins.left - margins.right;

    const vizIndividualsCanvas = vizIndividualsContainer.append("canvas")
      .attr("width", width)
      .attr("height", height)
      .style("position", "absolute")
      .style("top", '0px')
      .style("left", '0px');

    const svg = vizIndividualsContainer.append("svg")
      .attr("width", width)
      .attr("height", height)
      .style("position", "absolute")
      .style("top", '0px')
      .style("left", '0px');

    // Add interactive area, which is just a transparent rect
    const interactiveArea = svg
      .append("g")
      .attr("id", "interactiveArea")

    interactiveArea.append("rect")
      .attr("width", width)
      .attr("height", height)
      .attr("x", 0)
      .attr("y", 0)
      .attr("opacity", 0);

    // Create tooltip div programmatically using d3
    const tooltipDiv = vizIndividualsContainer
      .append("div")
      .attr("id", "tooltip")
      .attr("class", "tooltip")
      .style("visibility", "hidden")
      .style("position", "absolute")
      .style("background", "white")
      .style("padding", "10px")
      .style("border", "1px solid black")
      .style("pointer-events", "none");


    //set up for map
    const widthMap = 928;
    const heightMap = 581;
    // Create the container SVG for map
    const svgMap = d3.select("div#hexbinMap")
      .append("svg")
      .attr("viewBox", [0, 0, widthMap, heightMap])
      .attr("width", widthMap)
      .attr("height", heightMap)
      .attr("style", "max-width: 100%; height: auto;");
    const mapArea = svgMap.append("g");

    const loadIndividuals = async function () {
      let data = await d3.csv("data/241027_archinect_salaries_fulltime.csv", d3.autoType);
      console.log(data);
      //for testing purposes can change data to dataAll, and set this data as something else
      //let data = dataAll

      const satisfactionExtent = d3.extent(data, d => d['Job Satisfaction'])
      //starting color in UI colors: #043565 for blue, #ff8f06 for orange using https://uicolors.app/create

      // const satisfactionColors = ["#3c5491", "#4465b1", "#4e78c2", "#6290cf", "#a9c9e7", "#ffe3a8", "#ffce70", "#ff8f06", "#f07706", "#c75a07"]

      const uniqueSatisfactionValues = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

      const BuOrColorInterpolator = d3.piecewise(d3.interpolateRgb, ['#0a1869', '#a9c9e7', "#ffe3a8", '#fc6f03']);
      const colorInterpolator = (x) => BuOrColorInterpolator(d3.scaleLinear().domain(satisfactionExtent).range([0, 1])(x));
      const satisfactionColors = uniqueSatisfactionValues.map(d => colorInterpolator(d));

      //d3.schemeRdYlBu[10])
      const satisfactionScale = d3.scaleQuantize(satisfactionExtent, satisfactionColors)
      //more colors see: https://d3js.org/d3-scale-chromatic/diverging

      const salaryExtent = d3.extent(data, d => d['Salary'])
      //console.log("salaryExtent", salaryExtent)
      const salaryScale = d3.scaleSqrt().domain(salaryExtent).range([0.5, 15])

      //map related scales and set up
      // const us = await d3.json("data/us-counties-10m.json");
      // const stateMesh = topojson.mesh(us, us.objects.states);

      //const us = await d3.json("data/cb_2023_us_20m.json");
      //console.log("us", us);
      const states = await d3.json("data/cb_2023_us_state_5m.json");
      console.log("states", states);
      const stateMesh = topojson.mesh(states, states.objects.cb_2023_us_state_5m);

      const projection = geoAlbersUsaPr().scale(4 / 3 * widthMap).translate([widthMap / 2, heightMap / 2]);

      // Append the state mesh.
      mapArea.append("path")
        .datum(stateMesh)
        .attr("fill", "none")
        .attr("stroke", "#777")
        .attr("stroke-width", 0.5)
        .attr("stroke-linejoin", "round")
        .attr("d", d3.geoPath(projection));
      //set up the layer used for hexBin rendering
      let hexBinLayer = mapArea.append("g");


      //filter used for updates
      var filters = {};

      function pointPassesFilters(point) {

        let stillPassed = true;

        Object.values(filters).forEach(filterFunc => {
          stillPassed = filterFunc(point) && stillPassed;
        });

        return stillPassed;
      }


      //setting up spacing for individuals
      const cxCalc = (i, numPointsPerRow, maxD, xOffset) => Math.floor(i % (numPointsPerRow)) * maxD + xOffset;
      const cyCalc = (i, numPointsPerRow, maxD, yOffset) => Math.floor(i / (numPointsPerRow)) * maxD + yOffset;

      //TODO: need more dynamic maxD calculation, right now doesn't change with selections
      const medianSalaryOverall = d3.median(data, d => d['Salary']);
      //const maxD = 10
      const maxD = Math.ceil(salaryScale(medianSalaryOverall) * 2 + 2);
      const numPointsPerRow = Math.floor(vizWidth / maxD);
      const xOffset = maxD / 2 + margins.left;
      const yOffset = maxD / 2 + margins.top;

      data.forEach((d, i) => {
        d.cx = cxCalc(i, numPointsPerRow, maxD, xOffset);
        d.cy = cyCalc(i, numPointsPerRow, maxD, yOffset);
        d.color = satisfactionScale(d['Job Satisfaction'])
        d.passesFilter = true;
      });

      //canvas drawing
      const context = vizIndividualsCanvas.node().getContext("2d");

      //canvas interaction
      //code originally from Cornell INFO 3310 course notes, fall 2023
      let delaunay = d3.Delaunay.from(data, d => d.cx, d => d.cy);;
      let voronoi = delaunay.voronoi([0, 0, width, height]);;
      //TODO: uncomment to see voronoi
      // interactiveArea.append("path").attr("stroke", "black").attr("fill", "none").attr("d", voronoi.render());


      // simulate mouseOver and mouseOut for each circle
      let currentTarget = -1;
      interactiveArea.on("mousemove", function (event) {
        let loc = d3.pointer(event);
        let index;
        if (currentTarget === -1) {
          // Does a sweep of triangles, which should be O(sqrt(N)) in most cases
          index = delaunay.find(loc[0], loc[1]); // returns index of closest point
        }
        else {
          // With a known point index that's nearby, you can speed up the lookups dramatically
          index = delaunay.find(loc[0], loc[1], currentTarget)
        }
        // console.log(loc, index);

        if (index !== currentTarget) {
          currentTarget = index;
          mouseExitedIndividual();
          mouseEnteredIndividual(index);
        }
      });
      // Also trigger "mouseout" when leaving interactive area
      interactiveArea.on("mouseout", () => {
        currentTarget = -1;
        mouseExitedIndividual();
      })

      function mouseEnteredIndividual(i) {
        let d = data[i];

        if (d.passesFilter) {
          interactiveArea.append("circle")
            .attr("cx", d.cx)
            .attr("cy", d.cy)
            .attr("class", "highlight")
            .attr("opacity", 1)
            .attr("fill", d.color)
            .attr("pointer-events", "none")
            .attr("r", salaryScale(d['Salary']))
            // .transition().duration(200)
            // .attr("r", salaryScale(d['Salary']) + 5)
            ;

          interactiveArea.append("circle")
            .attr("class", "highlight")
            .attr("cx", d.cx)
            .attr("cy", d.cy)
            .attr("stroke", "black")
            .attr("stroke-width", 2)
            .attr("fill", "none")
            .attr("pointer-events", "none")
            // .attr("r", salaryScale(d['Salary']))
            // .transition().duration(200)
            .attr("r", salaryScale(d['Salary']) + 4)

            ;

          //TODO: absolute positions are not working, need to fix
          // console.log("tooltipDiv width", tooltipDiv.style("width"))
          // console.log("tooltipDiv left location", d.cx + 15)
          // console.log("canvas width", width)
          // const tooltipWidth = Number(tooltipDiv.style("width").replace("px", ""))
          // let tooltipLeft = d.cx + 15 + tooltipWidth > width - margins.right ? d.cx - tooltipWidth - 15 : d.cx + 15

          tooltipDiv.html(`
        <strong>Salary:</strong> ${d3.format("$,")(d['Salary'])}<br>
        <strong>Job Satisfaction:</strong> ${d['Job Satisfaction']}/10<br>
        <strong>Age:</strong> ${d['Age']}<br>
        <strong>Years of Experience:</strong> ${d['Years of Experience']}<br>
        <strong>Location:</strong> ${d['Location']}<br>
        <strong>Survey Date:</strong> ${new Date(d['Date']).toLocaleString('default', { month: 'long', year: 'numeric' })}<br>`)
            .style("left", `${d.cx + 15}px`)
            .style("top", `${d.cy + 15}px`)
            .style("visibility", "visible");
        }

      }
      function mouseExitedIndividual() {
        d3.selectAll("circle.highlight").remove();
        tooltipDiv.style("visibility", "hidden");
      }

      function updateData() {
        //filter for passing data
        const passingData = data.filter(pointPassesFilters);
        const passingDataSize = passingData.length;
        //console.log("passingDataSize", passingDataSize)

        hexbinMap(projection, passingData, "satisfaction", "length", hexBinLayer, widthMap, heightMap);

        const medianSalary = d3.median(passingData, d => d['Salary']);
        const meanSatisfaction = d3.mean(passingData, d => d['Job Satisfaction']);

        d3.select("h2#summaryText")
          .text(passingDataSize > 0 ? `Showing ${d3.format(",")(passingDataSize)} out of ${d3.format(",")(data.length)} individuals. Median Salary: ${d3.format("$,")(medianSalary)}, Mean Satisfaction: ${d3.format(".2f")(meanSatisfaction)}/10` : "No data selected")



        // Add cx and cy properties to each data point based on the index in data
        data.forEach((d, i) => {
          d.passesFilter = pointPassesFilters(d);
        });


        // Re-render the canvas
        context.clearRect(0, 0, width, height);
        context.globalAlpha = 0.8;
        // Draw points that don't pass the filter first
        data.forEach(d => {
          if (!d.passesFilter) {
            context.beginPath();
            context.arc(d.cx, d.cy, salaryScale(d['Salary']), 0, 2 * Math.PI);
            context.fillStyle = "lightgray";
            context.fill();
          }
        });

        // Draw points that pass the filter on top
        data.forEach(d => {
          if (d.passesFilter) {
            context.beginPath();
            context.arc(d.cx, d.cy, salaryScale(d['Salary']), 0, 2 * Math.PI);
            context.fillStyle = d.color;
            context.fill();
          }
        });

      }

      //sets up contols
      let controlWidth = 320;
      let controlHeight = 70;

      let controlSalary = d3.select("#controlfilterSalary");
      function getButtonDataSalary(attribute, values) {
        return [
          { label: "> $50k", filterFunc: d => d[attribute] > 50000 },
          { label: "> $100k", filterFunc: d => d[attribute] > 100000 },
          { label: "top 20 incomes", filterFunc: d => d[attribute] >= values[19] }
        ];
      }

      curveSlider(data, controlSalary, "Salary", "Salary", controlWidth, controlHeight, updateData, filters, { maxLimit: 200000, scaleFormatter: d => d === 0 ? "$0" : d3.format("$.2s")(d), getButtonData: getButtonDataSalary });

      let controlTime = d3.select("#controlfilterTime");
      clickableHistogramSlider(data, controlTime, "Survey Year", "Year", controlWidth, controlHeight, updateData, filters, { yBetweenLabelAndHist: 0 });

      let controlSatisfaction = d3.select("#controlfilterSatisfaction");
      // curveSlider(data, controlSatisfaction, "Job Satisfaction", "Job Satisfaction", controlWidth, controlHeight + 30, updateData, filters, { maxLimit: 11, scaleFormatter: d3.format(""), numBins: 10 });
      clickableHistogramSlider(data, controlSatisfaction, "Job Satisfaction", "Job Satisfaction", controlWidth, controlHeight, updateData, filters, { colorList: satisfactionColors, yBetweenLabelAndHist: 0 });

      let controlFirmType = d3.select("#controlfilterFirmType");
      clickableHistogramSlider(data, controlFirmType, "Firm Type", "Firm Type", controlWidth, controlHeight, updateData, filters, { sortOrder: ["Boutique", "Corporate", "Individual", "Starchitect", "Other", "N/A"] });

      let controlFirmSize = d3.select("#controlfilterFirmSize");
      clickableHistogramSlider(data, controlFirmSize, "Firm Size", "Firm Size", controlWidth, controlHeight, updateData, filters, { sortOrder: [1, "2-5", "6-10", "11-15", "16-30", "31-50", "51-100", "101-200", "201-500", "501+"], rotateAxisLabels: true });


      let controlAge = d3.select("#controlfilterAge");
      clickableHistogramSlider(data, controlAge, "Age", "Age", controlWidth, controlHeight, updateData, filters, { sortOrder: ["18-20", "21-25", "26-30", "31-35", "36-40", "41-45", "46-50", "51-55", "56-60", "61-65", "66-70", "71-103"], rotateAxisLabels: true });

      //testing class creations
      let controlAgeClass = d3.select("#controlfilterAgeClass");
      const histogramClassTest = new clickableHistogramSliderClass(data,
        controlAgeClass, "Age", "Age", controlWidth, controlHeight, updateData, filters, { sortOrder: ["18-20", "21-25", "26-30", "31-35", "36-40", "41-45", "46-50", "51-55", "56-60", "61-65", "66-70", "71-103"], rotateAxisLabels: true }
      );
      console.log("histogramClassTest", histogramClassTest);
      //call update data to draw the initial data
      updateData();

    }

    loadIndividuals();

    //this is d3 stock example
    // d3.select("div#hexbinMap").node().appendChild(await hexbinMap());

  </script>
</body>

</html>